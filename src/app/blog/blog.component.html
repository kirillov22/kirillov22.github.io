<div>
  <h1>Practical Test Driven Development using Ktor</h1>
  <h2>Preamble</h2>
  <p>I have always wanted to get into blogging and finally, the time has come. I am sitting here writing my first ever article and it all happened
    because of a YouTube comment. The comment was only meant to be a few paragraphs long, but it eventually turned into a crazy long post.
    <a href="https://www.youtube.com/watch?v=yfP_v6qCdcs&lc=UgyYduHcMnCzMkIF8b94AaABAg.9S3LUd9Fgtv9S3ngtWyran">Check it out here if you are interested</a>
    (you'll need to scroll down to the comment section to see it).
  </p>
  <p>
    I have never felt the need to leave a comment on anything online because I feel like I am not contributing
    anything of value and I do not want to pollute the already difficult to navigate comment sections with more noise. However, in this instance, I
    felt the urge to write a comment.
  </p>
  <q>
    This kind of content is great! Getting started with TDD is hard.

    I'd love to pay for a TDD course which focuses less on the classical katas and more on backend web development.
    What happens when we have a /fizzbuzz POST endpoint and save the result to a database, for example?
  </q>
  <p>
    This was the original comment I was replying to. Something really clicked when I read that comment.
    Perhaps it was because I saw a younger version of myself when reading the comment who was also in the same position a few years ago. Perhaps it was because
    so many examples online do not reflect the reality of software development. I am tired of reading the documentation for new frameworks,
    programming languages, tools, or development paradigms that have bad examples which do not reflect real-world usage.
    Recently I ran into this exact problem. I was trying to understand how dependency injection worked in a particular framework
    <a href="https://docs.micronaut.io/latest/guide/#ioc">I am looking at you Micronaut</a>. Their example of a vehicle and engines just added more
    complexity because I had to translate their analogy and apply it to what I was working on (creating a web api using the MVC pattern).
    I already had an understanding of dependency injection so I did not need an analogy. I was not building a car, I was building a web api, I was using
    a web framework to make a web api, why are the example not related to common web api usages and patterns?
    If I didn't understand dependency injection then I would read up about it and come back to the documentation once I was ready.
  </p>
  <p>
    Don't get me wrong, I do like the micronaut framework, but their docs just drive me nuts at times. I think this may have been why I felt so
    compelled to reply to that comment. I could feel the frustration that they felt and I wanted to do something about it.
    Anyway, here is my attempt at sharing (hopefully) some practical knowledge without the added bullshit.
    I hope you enjoy it, but more importantly, I hope that you can take something away from this.
  </p>
  <h1>Prerequisites</h1>
  <p>
    This article assumes you have some prior experience working with web apis and have an understanding of the following concepts:
  </p>
  <ul>
    <li>Have a basic understanding of TDD</li>
    <li>Have a basic understanding of modern web frameworks that follow the MVC pattern</li>
    <li>Have a basic understanding of dependency injection</li>
    <li>Have a basic understanding of mocking libraries</li>
    <li>Have a REST client that you are comfortable with such as Postman, curl, or Insomnia</li>
    </ul>
  <h1>Code Along</h1>
  <p>
    It is not necessary to code along to get benefit from this article, but if you wish to do so follow these steps to get started:
  </p>
  <ul>
    <li>Before getting started if you want to code along instead of just reading you can <a href="https://github.com/kirillov22/ktor-tdd">clone the repo from GitHub</a></li>
    <li>Read the readme in the project on how to get started if you want to code along. It is best if you start from <a href="https://github.com/kirillov22/ktor-tdd/tree/7c7a04197e2a0f655de104e5b9bb862e417cfcb7">this commit</a></li>
    <li>You can switch to that commit which has the starting code with the following command:</li>
  </ul>
  <pre><code [highlight]="gitCheckout"></code></pre>
  <h1>Project Brief</h1>
  <p>
    In this project, we will build a simple RESTFul CRUD (create, read, update and delete) api written in Kotlin using the Ktor framework.
    I have chosen to create an api for managing student information at a fictitious university. This is because it is a realistic example of
    something that you would build in the real world. Here is a rough breakdown of how it should work.
  </p>
  <ul>
    <li>It will return information about student enrollments and student grades.</li>
    <li>It will follow the MVC pattern where we have a controller that defines the endpoints, parses requests and returns responses, a service class
      that will handle the business logic of the app, and a repository class that will handle data storage and persistence.</li>
    <li>Finally, we will also be using the Kodein library for dependency injection, MockK for mocking, and Kotlin-test for unit testing.</li>
  </ul>
  <p>
    Why did I choose to use these technologies? I have previously built apis using C#, NodeJS, and Java, but I have yet to build a full-blown Kotlin REST api.
    This seemed like a perfect opportunity for me to try it out, learn something new and see how it compares to the technologies I have used.
  </p>
  <h1>Project Structure</h1>
  <img src="../../assets/blog/ktor-tdd/ktor-tdd-project-structure.png" alt="project structure">
  <p>
    We have a few sub-directories in our project that organise the files in a way that you would normally see in an enterprise environment.
    I will briefly explain what they are all for, but I encourage you to have a look and get familiar with the files.
  </p>
  <ul>
    <li><code>Application.kt</code> - This is the main entry point into our application. We will be performing the dependency injection here, in a more complex
      application it might be a good idea to separate the dependency injection into its own file, but it is ok for now as we have a simple application.</li>
    <li><code>controller</code> - This is where the endpoints and routes are defined. We will be handling the requests and responses here.</li>
    <li><code>model</code> - This is where we define the model/ data classes in our application.</li>
    <li><code>repository</code> - This is where we will handle the data persistence in our application.</li>
    <li><code>service</code> - This is where we will handle the bulk of the business logic of our application.</li>
    <li><code>test</code> - This is where we will have all of our tests. The test directory should reflect the main code structure so it is easier to follow.
      We will be adding more test files and directories as we go.</li>
  </ul>
  <h1>Lets get coding</h1>
  <p>
    I have included a simple response for one of the endpoints to test that everything is setup and working correctly. Run the app and make a GET request
    either in your browser or some other client to <code>localhost:8080/students</code> and see if you get the following response back.
  </p>
  <pre><code [highlight]="expectedStudentResponse"></code></pre>
  <p>
    If that works then go ahead and replace the code for the student endpoint with <code>TODO()</code>. We are going to do proper TDD where we write
    the tests first and then the actual code to pass the tests.
  </p>
  <h1>TDD for the controller</h1>
  <p>
    Once that is all working let's start in true TDD fashion and run the tests. We should see that the test fails. That's ok we are going to fix it.
    However, before we do that let's actually put the test in a better location. Create a new directory called <code>controller</code> inside the main
    test directory with a file called <code>StudentControllerTestCase</code>.
  </p>
  <h2>GET /students</h2>
  <p>
    In that class, we will add the following code which will be testing the <code>/students</code> endpoint.
  </p>
  <pre><code [highlight]="studentControllerTestCase"></code></pre>
  <p>
    What we are doing here is creating a test server in the <code>configure()</code> function. This serves as our system under test and we are mocking
    out the student service class to always return the same students each time it is called. We then assert that the HTTP status code returned from the
    api call is 200 (OK) and that the expected students are returned. Now run the tests and see that they fail because we have not implemented the code
    in the controller to call the student service. Let's add that into the controller, it should look like this:
  </p>
  <pre><code [highlight]="studentController"></code></pre>
  <h2>{{ studentById }}</h2>
  <p>
    In this part, we will be writing the test and the code for the endpoint that retrieves a single student by their id. We have the following requirements
    that we need to meet for the endpoint.
  </p>
  <ul>
    <li>If the given student id does not match any in the system then it must return a 404 (Not Found) status code</li>
    <li>If the given student id is not an integer then it must return a 400 (Bad Request) status code</li>
    <li>Otherwise, if all the above conditions are not met then it must return a 200 (OK) status code and the matching student</li>
  </ul>
  <p>
    Let's start by creating the test. Add the following code to your test file to test all these cases.
  </p>
  <pre><code [highlight]="studentByIdTests"></code></pre>
  <p>
    Notice when we add the test code we get a syntax error saying that there is a type mismatch on the mock of the student service. This is one of
    the many ways that TDD helps to write better code. Sure you can quickly go and change the code to return the correct type, but when practicing TDD
    you actually take a moment to pause and think about your design. In our case, we need to think about how will we represent the fact we did not find
    a student with the given id. Will we throw some sort of exception? Will we return a null value? Or will we return some default value? I rarely
    find myself doing this when I write the code first and the tests later. I think its mainly because I am in a mindset where I need to write code as
    fast as possible without putting too much thought into it. I then realise that I've created some big mess and it has become too difficult to test
    or I am just too lazy to write the tests because of some poor design choices. I have been in many situations like that and that is why I have come
    to like TDD more and more. It forces me to stop, and think about the code I am about to write instead of just picking the first thing that I think
    will work.
  </p>
  <p>
    Let's fix the syntax error by making the function in the student service return a nullable of type student. After you have done that go ahead and
    run the tests again. This time everything should compile, but two of the tests should be failing.
  </p>
  <p>
    Now that we have the tests ready and we are happy with them we can start writing the actual code without fear of making a mistake when refactoring
    because we have the safety of the tests. Add the following code to your student by id endpoint in the controller and it should make all the tests
    pass.
  </p>
  <pre><code [highlight]="studentByIdCode"></code></pre>
  <p>
    Make sure to run the tests and ensure they pass. If they do not go ahead and fix them up before you move on.
  </p>
  <h2>{{ addStudent }}</h2>
  <p>
    In this section, we will be implementing the endpoint that allows us to add a new student. We have the following requirements that we need to meet
    for this endpoint.
  </p>
  <ul>
    <li>
      If the given request does not match the api spec we should return a 400 (Bad Request) status code.
      We must also include a message explaining why the request is malformed
    </li>
    <li>
      If the given request matches the spec we should do the following:
      <ul>
        <li>Return a 201 (Created) status code</li>
        <li>Return an id for the newly created student</li>
        <li>Persist the new student so they can be retrieved in subsequent requests such as getting all students or getting a student by their id</li>
      </ul>
      Note: In this example, we will be implementing the id incrementing in the student service and not the controller.
      Do not worry about that for now, in the tests we will mock this out.
    </li>
  </ul>
  <p>
    Add the following code to our <code>StudentControllerTestCase</code> class:
  </p>
  <pre><code [highlight]="addStudentTests"></code></pre>
  <p>Add the following code to the <code>StudentService</code> class:</p>
  <pre><code [highlight]="addStudentService"></code></pre>
  <p>Create a new model file called <code>AddStudent</code> with the following contents:</p>
  <pre><code [highlight]="addStudentModel"></code></pre>
  <p>I have decided to generate the IDs for students on the server so a separate DTO class is needed for the request to add a student.</p>
  <p>
    As always let's start by running the tests and see that the new ones we have added have failed. Now we can write the code to make the tests pass.
    Add the following code and re-run the tests.
  </p>
  <pre><code [highlight]="addStudentCode"></code></pre>
  <p>They should now all be passing!</p>
  <h2>{{ updateAndDeleteStudent }}</h2>
  <p>
    I will not be showing the code for these two endpoints in the tutorial as it will make this tutorial far too long. You can still find the rest of
    the code in the GitHub repo. For your reference, these are the requirements for the two endpoints.
  </p>
  <h3>Update student</h3>
  <ul>
    <li>Return a 200 (OK) status code if the student is updated successfully</li>
    <li>When updating a student the average GPA must be recalculated and saved</li>
    <li>
      Return a 400 (Bad Request) status code if an update to a field is attempted that does not match the api spec
    </li>
  </ul>
  <h3>Delete student</h3>
  <ul>
    <li>Return a 200 (OK) status code if the student was deleted successfully</li>
    <li>Return a 400 (Bad Request) status code if the student id is not an integer</li>
    <li>Return a 404 (Not Found) status code if the student to be deleted with the given id does not exist</li>
  </ul>
  <h1>TDD for the service</h1>
  <p>
    Now that we have the controller working, at least a few of the endpoints, we can test our api a bit more in-depth and we can start fleshing out the
    student service class. This will be where the core of our business logic will reside. To get started create a new class in the tests
    directory called <code>StudentServiceTestCase</code>
  </p>
  <p>
    This is where we will use separation of concerns to make developing and testing our code much easier. Instead of putting all of the logic into the
    controller, we will separate out the validation logic and core business logic. The controller will do some simple validation like making sure all the
    fields are correct and match the api schema (most frameworks will do this for you already). We will then implement the requirements for the
    endpoint in the service classes. For example, when updating a student we will recalculate the average GPA in the service class instead of the
    controller to separate things out and make it easier to test and extend in the future.
  </p>
  <p>
    Add the following tests to the service class and then we can get to writing the code to satisfy the test cases.
  </p>
  <pre><code [highlight]="studentServiceTestCaseCode"></code></pre>
  <p>
    Whoa! That is quite a lot of code, but those ~190 lines of code should be enough to give us confidence that our application will work.
    At this point, it would be good to submit a pull request for your colleagues to take a look at what you've come up with.
    This gives you many benefits that you wouldn't normally get if you had written the code upfront and the tests afterward.
    Perhaps you misinterpreted some requirements, or maybe there is a flaw in the design of the code that they can now see that they may have overlooked
    previously. Another reason why getting a review for only tests is that the test code will actually get scrutinized properly. I think most of the time
    developers (I am guilty of this myself 😅) skip through the tests in the PR because they have already spent a lot of time peering
    over the code, especially if it's a large PR. Most of the time test code is only properly reviewed when the next developer comes along to fix or
    update tests and that is usually a frustrating time.
  </p>
  <h1>Student Service Code</h1>
  <p>
    Now that we have our tests written we can start working on the actual code. Even when writing the code myself I had to make small adjustments to
    the tests and how the code is structured. This is completely normal because chances are you are never going to write something 100%
    correct the first time around. This is why you should make small incremental changes instead of doing a week's worth of work only to realise you
    had an incorrect assumption, realise the requirements were not clear and were ambiguous.
    Add the following code to satisfy the tests:
  </p>
  <pre><code [highlight]="studentServiceCode"></code></pre>
  <p>
    This is obviously a simplified example, in the real world, your business logic will most likely be far more complex than this so writing the tests
    before the code is even more important. One other reason is that writing the tests before the code makes you actually go and read the code properly,
    get an understanding of how it works and how it fits into the system. It will seem like a waste of time going through all the code and trying to wrap
    your head around it, but this will help you understand the system as a whole better and you can make better architectural decisions later down the
    track. You might be able to see areas that can be refactored to make the code simpler and more re-usable or you could see a way to make the code
    more performant.
  </p>
  <h1>Student Repository Tests</h1>
  <p>
    We are almost there! Just some more tests to write and we will be good to go. Start off by creating a new class called:
    <code>StudentRepositoryTestCase</code>. Inside it add the following code to satisfy our requirements.
  </p>
  <pre><code [highlight]="studentRepositoryTestCaseCode"></code></pre>
  <p>
    In this example, we are using a local JSON file as our data store, but this concept can be applied to any other form of data storage
    (relational database, NoSQL database, etc.). They are all built around similar concepts, they abstract away the implementation and provide an API
    for us to consume. We do not need to understand how exactly Postgres, Mongo, Firebase, or any other form of data store implements their logic to
    read and save data. We just rely on the contract that is provided with the API and we are able to mock out the implementation of the data store in
    our tests so that we are sure our code is working without worrying about testing the data store code itself. That code should be tested by the
    authors of the data store.
  </p>
  <h1>Student Repository Code</h1>
  <p>
    This is the code that will satisfy all of the tests for the student repository. It might not be the most performant or most elegant solution, but
    now that we have tests in place we can refactor to our heart's content without worrying that we break the implementation. Once all tests are green
    then we should have enough confidence in starting the next step in the development process. For example, we could push our code and have a peer
    review, or perhaps we pair programmed this bit of code and we are ready to release it to production.
  </p>
  <h1>Conclusion</h1>
  <p>
    In this post, we have covered a number of different topics, strategies, and principles to apply when developing code in a TDD fashion. We have used
    separation of concerns by creating clear and well-encapsulated boundaries between different areas of the system to split up the code into logical
    chunks which makes understanding the system much easier. We have also used mocking in conjunction with this to aid testing our code by swapping
    out the behaviour of dependencies to test different code paths and scenarios. Finally, we used dependency injection to allow easy
    substitution of dependencies when writing tests and to allow us to easily change the behaviour of those dependencies.
  </p>
  <p>
    Hopefully, you have learned something useful from this blog and that TDD can be applied to 'real-life' scenarios too, it just takes a bit of time
    to get your head around it. As a final exercise, I encourage you to extend this API and use a different data store (Redis, Postgres, Couchbase, etc.)
    to write and persist the data for this student management system.
  </p>
</div>
